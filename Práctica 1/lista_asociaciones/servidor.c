/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "asociacion.h"

typedef enum {
	false,
	true
} bool;

ListaPtr raiz = NULL;

State *
ponerasociacion_1_svc(datos_nueva_asociacion* data,  struct svc_req *rqstp)
{
	static State result;	
	datos_nueva_asociacion argumento = *data;

	if(raiz==NULL) { 
		ElementoPtr elem = (ElementoPtr)malloc(sizeof(Elemento));
		elem->key = strdup(argumento.key);
		elem->content = strdup(argumento.content);
		elem->sig = NULL;
		ListaPtr list = (ListaPtr)malloc(sizeof(Lista));  
		list->id = argumento.id;
		list->sig = NULL;
		list->first = elem;
		raiz = list;
		result = VALIDO;
	} else { 
		ListaPtr listPtr = raiz; 
		bool encontradoID = false;
		if(listPtr->id==argumento.id) {
			encontradoID = true;
		}
		while(encontradoID==false && listPtr->sig!=NULL) {
			listPtr = listPtr->sig;
			if(listPtr->id==argumento.id) {
				encontradoID = true;
			}
		}
		if(encontradoID==true) {
			ElementoPtr elemPtr = listPtr->first;
			bool encontradoKey = false;
			if(strcmp(elemPtr->key,argumento.key)==0) {
				encontradoKey = true;
			}
			while(encontradoKey==false && elemPtr->sig!=NULL) { 
				elemPtr = elemPtr->sig;
				if(strcmp(elemPtr->key,argumento.key)==0) {
					encontradoKey = true;
				}
			}
			if(encontradoKey==true) { 
				elemPtr->content = strdup(argumento.content);
				result = SUSTITUIDO;
			} else { 
				ElementoPtr elem = (ElementoPtr)malloc(sizeof(Elemento));
				elem->key = strdup(argumento.key);
				elem->content = strdup(argumento.content);
				elem->sig = NULL;
				elemPtr->sig = elem;
				result = VALIDO;
			}
		} else { 
			ElementoPtr elem = (ElementoPtr)malloc(sizeof(Elemento));
			elem->key = strdup(argumento.key);
			elem->content = strdup(argumento.content);
			elem->sig = NULL;
			ListaPtr list = (ListaPtr)malloc(sizeof(Lista));  
			list->id = argumento.id;
			list->sig = NULL;
			list->first = elem;
			listPtr->sig = list;
			result = VALIDO;
		}
	}

	return &result;
}

ResultElemento *
obtenerasociacion_1_svc(datos_asociacion* data,  struct svc_req *rqstp)
{
	static ResultElemento result;
	datos_asociacion argumento = *data;

	if(raiz==NULL) { 
		result.state = ERROR;
	} else {
		ListaPtr listPtr = raiz;
		bool encontradoID = false;
		if(listPtr->id==argumento.id) {
			encontradoID = true;
		}
		while(encontradoID==false && listPtr->sig!=NULL) { 
			listPtr = listPtr->sig;
			if(listPtr->id==argumento.id) {
				encontradoID = true;
			}
		}
		if(encontradoID==true) { 
			ElementoPtr elemPtr = listPtr->first;
			bool encontradoKey = false;
			if(strcmp(elemPtr->key,argumento.key)==0) {
				encontradoKey = true;
			}
			while(encontradoKey==false && elemPtr->sig!=NULL) { 
				elemPtr = elemPtr->sig;
				if(strcmp(elemPtr->key,argumento.key)==0) {
					encontradoKey = true;
				}
			}
			if(encontradoKey==true) { 
				result.state = VALIDO;
				result.ResultElemento_u.content = strdup(elemPtr->content);
			} else { 
				result.state = ERROR;
			}
		} else { 
			result.state = ERROR;
		}
	}

	return &result;
}

State *
borrarasociacion_1_svc(datos_asociacion* data, struct svc_req *rqstp)
{
	static State result;
	datos_asociacion argumento = *data;

	if(raiz==NULL) { 
		result = ERROR;
	} else { 
		ListaPtr listPtr = raiz;
		bool encontradoID = false;
		if(listPtr->id==argumento.id) {
			encontradoID = true;
		}
		if(encontradoID==true) { 
			ElementoPtr elemPtr = listPtr->first;
			bool encontradoKey = false;
			if(strcmp(elemPtr->key,argumento.key)==0) {
				encontradoKey = true;
			}
			if(encontradoKey==true) { 
				if(elemPtr->sig==NULL) { 
					raiz = listPtr->sig;
					listPtr->sig = NULL;
					xdr_free((xdrproc_t)xdr_Lista,(char*)listPtr);
					result = VALIDO;
				} else { 
					listPtr->first = elemPtr->sig;
					elemPtr->sig = NULL;
					xdr_free((xdrproc_t)xdr_Elemento,(char*)elemPtr);
					result = VALIDO;
				}
			} else { 
				ElementoPtr elemPtrAnt = elemPtr;
				while(encontradoKey==false && elemPtr->sig!=NULL) { 
					elemPtrAnt = elemPtr;
					elemPtr = elemPtr->sig;
					if(strcmp(elemPtr->key,argumento.key)==0) {
						encontradoKey = true;
					}
				}
				if(encontradoKey==true) { 
					elemPtrAnt->sig = elemPtr->sig;
					elemPtr->sig = NULL;
					xdr_free((xdrproc_t)xdr_Elemento,(char*)elemPtr);
					result = VALIDO;
				} else { 
					result = ERROR;
				}
			}
		} else { 
			ListaPtr listPtrAnt;
			while(encontradoID==false && listPtr->sig!=NULL) { 
				listPtrAnt = listPtr;
				listPtr = listPtr->sig;
				if(listPtr->id==argumento.id) {
					encontradoID = true;
				}
			}
			if(encontradoID==true) { 
				ElementoPtr elemPtr = listPtr->first;
				bool encontradoKey = false;
				if(strcmp(elemPtr->key,argumento.key)==0) {
					encontradoKey = true;
				}
				if(encontradoKey==true) { 
					if(elemPtr->sig==NULL) { 
						listPtrAnt->sig = listPtr->sig;
						listPtr->sig = NULL;
						xdr_free((xdrproc_t)xdr_Lista,(char*)listPtr);
						result = VALIDO;
					} else {
						listPtr->first = elemPtr->sig;
						elemPtr->sig = NULL;
						xdr_free((xdrproc_t)xdr_Elemento,(char*)elemPtr);
						result = VALIDO;
					}
				} else { 
					ElementoPtr elemPtrAnt = elemPtr;
					while(encontradoKey==false && elemPtr->sig!=NULL) {
						elemPtrAnt = elemPtr;
						elemPtr = elemPtr->sig;
						if(strcmp(elemPtr->key,argumento.key)==0) {
							encontradoKey = true;
						}
					}
					if(encontradoKey==true) { 
						elemPtrAnt->sig = elemPtr->sig;
						elemPtr->sig = NULL;
						xdr_free((xdrproc_t)xdr_Elemento,(char*)elemPtr);
						result = VALIDO;
					} else { 
						result = ERROR;
					}
				}
			} else {
				result = ERROR;
			}
		} 
	}

	return &result;
}

ResultLista *
enumerar_1_svc(ID* id,  struct svc_req *rqstp)
{
	static ResultLista  result;
	ID arg = *id;

	if(raiz==NULL) { 
		result.state = ERROR;
	} else { 
		ListaPtr listPtr = raiz;
		bool encontradoID = false;
		if(listPtr->id==arg) {
			encontradoID = true;
		}
		while(encontradoID==false && listPtr->sig!=NULL) {
			listPtr = listPtr->sig;
			if(listPtr->id==arg) {
				encontradoID = true;
			}
		}
		if(encontradoID==true) { 
			result.state = VALIDO;
			ElementoPtr elemPtr = listPtr->first;
			ElementoPtr sal = (ElementoPtr)malloc(sizeof(Elemento));
			sal = elemPtr;
			result.ResultLista_u.elemPtr = sal;
		} else {
			result.state = ERROR;
		}
	}

	return &result;
}
